/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
<<<<<<< HEAD
 * @flow
=======
 * @flow strict-local
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
 * @format
 */

'use strict';

const UIManager = require('../ReactNative/UIManager');
<<<<<<< HEAD

import Platform from '../Utilities/Platform';

type Type =
  | 'spring'
  | 'linear'
  | 'easeInEaseOut'
  | 'easeIn'
  | 'easeOut'
  | 'keyboard';

type Property = 'opacity' | 'scaleX' | 'scaleY' | 'scaleXY';

type AnimationConfig = $ReadOnly<{|
  duration?: number,
  delay?: number,
  springDamping?: number,
  initialVelocity?: number,
  type?: Type,
  property?: Property,
|}>;

export type LayoutAnimationConfig = $ReadOnly<{|
  duration: number,
  create?: AnimationConfig,
  update?: AnimationConfig,
  delete?: AnimationConfig,
|}>;

function configureNext(
  config: LayoutAnimationConfig,
  onAnimationDidEnd?: Function,
) {
  if (!Platform.isTesting) {
    UIManager.configureNextLayoutAnimation(
      config,
      onAnimationDidEnd ?? function() {},
      function() {} /* unused onError */,
    );
=======
import type {Spec as FabricUIManagerSpec} from '../ReactNative/FabricUIManager';
import type {
  LayoutAnimationConfig as LayoutAnimationConfig_,
  LayoutAnimationType,
  LayoutAnimationProperty,
} from '../Renderer/shims/ReactNativeTypes';

import Platform from '../Utilities/Platform';

// Reexport type
export type LayoutAnimationConfig = LayoutAnimationConfig_;

type OnAnimationDidEndCallback = () => void;
type OnAnimationDidFailCallback = () => void;

function configureNext(
  config: LayoutAnimationConfig,
  onAnimationDidEnd?: OnAnimationDidEndCallback,
  onAnimationDidFail?: OnAnimationDidFailCallback,
) {
  if (!Platform.isTesting) {
    if (UIManager?.configureNextLayoutAnimation) {
      UIManager.configureNextLayoutAnimation(
        config,
        onAnimationDidEnd ?? function() {},
        onAnimationDidFail ??
          function() {} /* this should never be called in Non-Fabric */,
      );
    }
    const FabricUIManager: FabricUIManagerSpec = global?.nativeFabricUIManager;
    if (FabricUIManager?.configureNextLayoutAnimation) {
      global?.nativeFabricUIManager?.configureNextLayoutAnimation(
        config,
        onAnimationDidEnd ?? function() {},
        onAnimationDidFail ??
          function() {} /* this will only be called if configuration fails */,
      );
    }
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  }
}

function create(
  duration: number,
<<<<<<< HEAD
  type: Type,
  property: Property,
=======
  type: LayoutAnimationType,
  property: LayoutAnimationProperty,
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
): LayoutAnimationConfig {
  return {
    duration,
    create: {type, property},
    update: {type},
    delete: {type, property},
  };
}

const Presets = {
  easeInEaseOut: (create(
    300,
    'easeInEaseOut',
    'opacity',
  ): LayoutAnimationConfig),
  linear: (create(500, 'linear', 'opacity'): LayoutAnimationConfig),
  spring: {
    duration: 700,
    create: {
      type: 'linear',
      property: 'opacity',
    },
    update: {
      type: 'spring',
      springDamping: 0.4,
    },
    delete: {
      type: 'linear',
      property: 'opacity',
    },
  },
};

/**
 * Automatically animates views to their new positions when the
 * next layout happens.
 *
 * A common way to use this API is to call it before calling `setState`.
 *
 * Note that in order to get this to work on **Android** you need to set the following flags via `UIManager`:
 *
 *     UIManager.setLayoutAnimationEnabledExperimental && UIManager.setLayoutAnimationEnabledExperimental(true);
 */
const LayoutAnimation = {
  /**
   * Schedules an animation to happen on the next layout.
   *
   * @param config Specifies animation properties:
   *
   *   - `duration` in milliseconds
   *   - `create`, `AnimationConfig` for animating in new views
   *   - `update`, `AnimationConfig` for animating views that have been updated
   *
   * @param onAnimationDidEnd Called when the animation finished.
   * Only supported on iOS.
   * @param onError Called on error. Only supported on iOS.
   */
  configureNext,
  /**
   * Helper for creating a config for `configureNext`.
   */
  create,
  Types: Object.freeze({
    spring: 'spring',
    linear: 'linear',
    easeInEaseOut: 'easeInEaseOut',
    easeIn: 'easeIn',
    easeOut: 'easeOut',
    keyboard: 'keyboard',
  }),
  Properties: Object.freeze({
    opacity: 'opacity',
    scaleX: 'scaleX',
    scaleY: 'scaleY',
    scaleXY: 'scaleXY',
  }),
  checkConfig(...args: Array<mixed>) {
    console.error('LayoutAnimation.checkConfig(...) has been disabled.');
  },
  Presets,
  easeInEaseOut: (configureNext.bind(null, Presets.easeInEaseOut): (
<<<<<<< HEAD
    onAnimationDidEnd?: any,
  ) => void),
  linear: (configureNext.bind(null, Presets.linear): (
    onAnimationDidEnd?: any,
  ) => void),
  spring: (configureNext.bind(null, Presets.spring): (
    onAnimationDidEnd?: any,
=======
    onAnimationDidEnd?: OnAnimationDidEndCallback,
  ) => void),
  linear: (configureNext.bind(null, Presets.linear): (
    onAnimationDidEnd?: OnAnimationDidEndCallback,
  ) => void),
  spring: (configureNext.bind(null, Presets.spring): (
    onAnimationDidEnd?: OnAnimationDidEndCallback,
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  ) => void),
};

module.exports = LayoutAnimation;
