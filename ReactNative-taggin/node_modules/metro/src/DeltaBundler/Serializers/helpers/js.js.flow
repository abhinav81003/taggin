/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 * @format
 */

'use strict';

<<<<<<< HEAD
const addParamsToDefineCall = require('../../../lib/addParamsToDefineCall');
const invariant = require('invariant');
const path = require('path');

import type {JsOutput} from '../../../JSTransformer/worker';
import type {MixedOutput, Module, Dependency} from '../../types.flow';
=======
const invariant = require('invariant');
const path = require('path');

const {addParamsToDefineCall} = require('metro-transform-plugins');

import type {MixedOutput, Module} from '../../types.flow';
import type {JsOutput} from 'metro-transform-worker';
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707

export type Options = {
  +createModuleId: string => number | string,
  +dev: boolean,
  +projectRoot: string,
  ...
};

function wrapModule(module: Module<>, options: Options): string {
  const output = getJsOutput(module);

  if (output.type.startsWith('js/script')) {
    return output.data.code;
  }

  const moduleId = options.createModuleId(module.path);
  const params = [
    moduleId,
<<<<<<< HEAD
    Array.from(module.dependencies.values()).map((dependency: Dependency) => {
      return options.createModuleId(dependency.absolutePath);
    }),
  ];

  // Add the module relative path as the last parameter (to make it easier to do
  // requires by name when debugging).
  if (options.dev) {
=======
    Array.from(module.dependencies.values()).map(dependency =>
      options.createModuleId(dependency.absolutePath),
    ),
  ];

  if (options.dev) {
    // Add the relative path of the module to make debugging easier.
    // This is mapped to `module.verboseName` in `require.js`.
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    params.push(path.relative(options.projectRoot, module.path));
  }

  return addParamsToDefineCall(output.data.code, ...params);
}

function getJsOutput(module: Module<>): JsOutput {
  const jsModules = module.output.filter(({type}) => type.startsWith('js/'));

  invariant(
    jsModules.length === 1,
<<<<<<< HEAD
    `Modules must have exactly one JS output, but ${module.path} has ${
      jsModules.length
    } JS outputs.`,
=======
    `Modules must have exactly one JS output, but ${module.path} has ${jsModules.length} JS outputs.`,
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  );

  const jsOutput = (jsModules[0]: any);

  invariant(
    Number.isFinite(jsOutput.data.lineCount),
<<<<<<< HEAD
    `JS output must populate lineCount, but ${module.path} has ${
      jsOutput.type
    } output with lineCount '${jsOutput.data.lineCount}'`,
=======
    `JS output must populate lineCount, but ${module.path} has ${jsOutput.type} output with lineCount '${jsOutput.data.lineCount}'`,
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  );

  return jsOutput;
}

function isJsModule(module: Module<>): boolean {
  return module.output.filter(isJsOutput).length > 0;
}

function isJsOutput(output: MixedOutput): boolean %checks {
  return output.type.startsWith('js/');
}

module.exports = {
  getJsOutput,
  isJsModule,
  wrapModule,
};
