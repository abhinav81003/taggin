/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
 * @flow
 */

'use strict';

<<<<<<< HEAD
/* eslint-disable lint/no-unclear-flowtypes */
const t = require('@babel/types');
/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
 * found when Flow v0.99 was deployed. To see the error, delete this comment
 * and run Flow. */
const template = require('@babel/template').default;

/* $FlowFixMe(>=0.99.0 site=react_native_fb) This comment suppresses an error
 * found when Flow v0.99 was deployed. To see the error, delete this comment
 * and run Flow. */
const traverse = require('@babel/traverse').default;
=======
import template from '@babel/template';
import traverse from '@babel/traverse';
import * as t from '@babel/types';
import type {Program, FunctionExpression, Identifier} from '@babel/types';
import invariant from 'invariant';
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707

const WRAP_NAME = '$$_REQUIRE'; // note: babel will prefix this with _

// Check first the `global` variable as the global object. This way serializers
// can create a local variable called global to fake it as a global object
// without having to pollute the window object on web.
<<<<<<< HEAD
const IIFE_PARAM = template(
=======
const IIFE_PARAM = template.expression(
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  "typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this",
);

function wrapModule(
<<<<<<< HEAD
  fileAst: Object,
  importDefaultName: string,
  importAllName: string,
  dependencyMapName: string,
): {
  ast: Object,
  requireName: string,
  ...
=======
  fileAst: BabelNodeFile,
  importDefaultName: string,
  importAllName: string,
  dependencyMapName: string,
  globalPrefix: string,
): {
  ast: BabelNodeFile,
  requireName: string,
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
} {
  const params = buildParameters(
    importDefaultName,
    importAllName,
    dependencyMapName,
  );
  const factory = functionFromProgram(fileAst.program, params);
<<<<<<< HEAD
  const def = t.callExpression(t.identifier('__d'), [factory]);
=======
  const def = t.callExpression(t.identifier(`${globalPrefix}__d`), [factory]);
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  const ast = t.file(t.program([t.expressionStatement(def)]));

  const requireName = renameRequires(ast);

  return {ast, requireName};
}

<<<<<<< HEAD
function wrapPolyfill(fileAst: Object): Object {
  const factory = functionFromProgram(fileAst.program, ['global']);

  const iife = t.callExpression(factory, [IIFE_PARAM().expression]);
  return t.file(t.program([t.expressionStatement(iife)]));
}

function wrapJson(source: string): string {
  // Unused parameters; remember that's wrapping JSON.
  const moduleFactoryParameters = buildParameters(
    '_aUnused',
    '_bUnused',
    '_cUnused',
  );

  return [
    `__d(function(${moduleFactoryParameters.join(', ')}) {`,
    `  module.exports = ${source};`,
=======
function wrapPolyfill(fileAst: BabelNodeFile): BabelNodeFile {
  const factory = functionFromProgram(fileAst.program, ['global']);

  const iife = t.callExpression(factory, [IIFE_PARAM()]);
  return t.file(t.program([t.expressionStatement(iife)]));
}

function jsonToCommonJS(source: string): string {
  return `module.exports = ${source};`;
}

function wrapJson(source: string, globalPrefix: string): string {
  // Unused parameters; remember that's wrapping JSON.
  const moduleFactoryParameters = buildParameters(
    '_importDefaultUnused',
    '_importAllUnused',
    '_dependencyMapUnused',
  );

  return [
    `${globalPrefix}__d(function(${moduleFactoryParameters.join(', ')}) {`,
    `  ${jsonToCommonJS(source)}`,
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    '});',
  ].join('\n');
}

function functionFromProgram(
<<<<<<< HEAD
  program: Object,
  parameters: $ReadOnlyArray<string>,
): Object {
  return t.functionExpression(
    t.identifier(''),
=======
  program: Program,
  parameters: $ReadOnlyArray<string>,
): FunctionExpression {
  return t.functionExpression(
    undefined,
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    parameters.map(makeIdentifier),
    t.blockStatement(program.body, program.directives),
  );
}

<<<<<<< HEAD
function makeIdentifier(name: string): Object {
=======
function makeIdentifier(name: string): Identifier {
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  return t.identifier(name);
}

function buildParameters(
  importDefaultName: string,
  importAllName: string,
  dependencyMapName: string,
): $ReadOnlyArray<string> {
  return [
    'global',
    'require',
    importDefaultName,
    importAllName,
    'module',
    'exports',
    dependencyMapName,
  ];
}

<<<<<<< HEAD
function renameRequires(ast: Object): string {
=======
// Renaming requires should ideally only be done when generating for the target
// that expects the custom require name in the optimize step.
// This visitor currently renames all `require` references even if the module
// contains a custom `require` declaration. This should be fixed by only renaming
// if the `require` symbol hasn't been redeclared.
function renameRequires(ast: BabelNodeFile): string {
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  let newRequireName = WRAP_NAME;

  traverse(ast, {
    Program(path) {
      const body = path.get('body.0.expression.arguments.0.body');

<<<<<<< HEAD
=======
      invariant(
        !Array.isArray(body),
        'metro: Expected `body` to be a single path.',
      );

>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
      newRequireName = body.scope.generateUid(WRAP_NAME);
      body.scope.rename('require', newRequireName);
    },
  });

  return newRequireName;
}

module.exports = {
  WRAP_NAME,

  wrapJson,
<<<<<<< HEAD
=======
  jsonToCommonJS,
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  wrapModule,
  wrapPolyfill,
};
