/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict-local
 * @format
 */

'use strict';

<<<<<<< HEAD
import typeof {types as BabelTypes} from '@babel/core';
import type {Path} from '@babel/traverse';
=======
import type {NodePath} from '@babel/traverse';
import typeof * as Types from '@babel/types';
import type {CallExpression} from '@babel/types';
import invariant from 'invariant';
import nullthrows from 'nullthrows';
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707

type State = {|
  opts: {|
    +dependencyIds: $ReadOnlyArray<number>,
<<<<<<< HEAD
=======
    +globalPrefix: string,
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  |},
|};

function reverseDependencyMapReferences({
  types: t,
}: {
<<<<<<< HEAD
  types: BabelTypes,
  ...
}): {|visitor: {|CallExpression: (path: Path, state: State) => void|}|} {
  return {
    visitor: {
      CallExpression(path: Path, state: State) {
        const {node} = path;

        if (node.callee.name === '__d') {
          const lastArg = node.arguments[0].params.slice(-1)[0];
          const depMapName = lastArg && lastArg.name;

          if (!depMapName) {
            return;
          }

          const scope = path.get('arguments.0.body').scope;
          const binding = scope.getBinding(depMapName);

          binding.referencePaths.forEach(({parentPath}) => {
            const memberNode = parentPath.node;

            if (
              memberNode.type === 'MemberExpression' &&
              memberNode.property.type === 'NumericLiteral'
            ) {
              parentPath.replaceWith(
                t.numericLiteral(
                  state.opts.dependencyIds[memberNode.property.value],
                ),
              );
=======
  types: Types,
  ...
}): {|
  visitor: {|
    CallExpression: (path: NodePath<CallExpression>, state: State) => void,
  |},
|} {
  return {
    visitor: {
      CallExpression(path: NodePath<CallExpression>, state: State) {
        const {node} = path;

        if (node.callee.name === `${state.opts.globalPrefix}__d`) {
          // $FlowFixMe Flow error uncovered by typing Babel more strictly
          const lastArg = node.arguments[0].params.slice(-1)[0];
          // $FlowFixMe Flow error uncovered by typing Babel more strictly
          const depMapName: ?string = lastArg && lastArg.name;

          if (depMapName == null) {
            return;
          }

          const body = path.get('arguments.0.body');
          invariant(
            !Array.isArray(body),
            'meetro: Expected `body` to be a single path.',
          );

          const scope = body.scope;
          const binding = nullthrows(scope.getBinding(depMapName));

          binding.referencePaths.forEach(({parentPath}) => {
            const memberNode = parentPath?.node;

            if (
              memberNode != null &&
              memberNode.type === 'MemberExpression' &&
              memberNode.property.type === 'NumericLiteral'
            ) {
              const numericLiteral = t.numericLiteral(
                state.opts.dependencyIds[memberNode.property.value],
              );
              nullthrows(parentPath).replaceWith(numericLiteral);
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
            }
          });
        }
      },
    },
  };
}

module.exports = reverseDependencyMapReferences;
