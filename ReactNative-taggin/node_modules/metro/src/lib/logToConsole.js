/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @format
<<<<<<< HEAD
=======
 *
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
 */

/* eslint-disable no-console */
"use strict";

<<<<<<< HEAD
function _toConsumableArray(arr) {
  return (
    _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread()
  );
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

function _iterableToArray(iter) {
  if (
    Symbol.iterator in Object(iter) ||
    Object.prototype.toString.call(iter) === "[object Arguments]"
  )
    return Array.from(iter);
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++)
      arr2[i] = arr[i];
    return arr2;
  }
}

=======
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
const chalk = require("chalk");

const groupStack = [];
let collapsedGuardTimer;

<<<<<<< HEAD
module.exports = (level, data) => {
  const logFunction = console[level] && level !== "trace" ? level : "log";
  const color =
    level === "error" ? "red" : level === "warn" ? "yellow" : "white";
=======
module.exports = function(terminal, level) {
  const logFunction = console[level] && level !== "trace" ? level : "log";
  const color =
    level === "error"
      ? chalk.inverse.red
      : level === "warn"
      ? chalk.inverse.yellow
      : chalk.inverse.white;
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707

  if (level === "group") {
    groupStack.push(level);
  } else if (level === "groupCollapsed") {
    groupStack.push(level);
    clearTimeout(collapsedGuardTimer); // Inform users that logs get swallowed if they forget to call `groupEnd`.

    collapsedGuardTimer = setTimeout(() => {
      if (groupStack.includes("groupCollapsed")) {
<<<<<<< HEAD
        console.warn(
=======
        terminal.log(
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
          chalk.inverse.yellow.bold(" WARN "),
          "Expected `console.groupEnd` to be called after `console.groupCollapsed`."
        );
        groupStack.length = 0;
      }
    }, 3000);
    return;
  } else if (level === "groupEnd") {
    groupStack.pop();

    if (!groupStack.length) {
      clearTimeout(collapsedGuardTimer);
    }

    return;
  }

  if (!groupStack.includes("groupCollapsed")) {
<<<<<<< HEAD
    var _console;

    (_console = console)[logFunction].apply(
      _console,
      [chalk.inverse[color].bold(` ${logFunction.toUpperCase()} `)].concat(
        _toConsumableArray(data)
      )
=======
    for (
      var _len = arguments.length,
        data = new Array(_len > 2 ? _len - 2 : 0),
        _key = 2;
      _key < _len;
      _key++
    ) {
      data[_key - 2] = arguments[_key];
    } // Remove excess whitespace at the end of a log message, if possible.

    const lastItem = data[data.length - 1];

    if (typeof lastItem === "string") {
      data[data.length - 1] = lastItem.trimEnd();
    }

    terminal.log.apply(
      terminal,
      [
        color.bold(` ${logFunction.toUpperCase()} `) +
          "".padEnd(groupStack.length * 2, " ")
      ].concat(data)
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    );
  }
};
