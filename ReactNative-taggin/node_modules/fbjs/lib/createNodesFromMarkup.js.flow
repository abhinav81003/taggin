/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @providesModule createNodesFromMarkup
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/
<<<<<<< HEAD

const ExecutionEnvironment = require('./ExecutionEnvironment');

const createArrayFromMixed = require('./createArrayFromMixed');
const getMarkupWrap = require('./getMarkupWrap');
const invariant = require('./invariant');

/**
 * Dummy container used to render all markup.
 */
const dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
const nodeNamePattern = /^\s*<(\w+)/;

=======
const ExecutionEnvironment = require("./ExecutionEnvironment");

const createArrayFromMixed = require("./createArrayFromMixed");

const getMarkupWrap = require("./getMarkupWrap");

const invariant = require("./invariant");
/**
 * Dummy container used to render all markup.
 */


const dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
/**
 * Pattern used by `getNodeName`.
 */

const nodeNamePattern = /^\s*<(\w+)/;
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
<<<<<<< HEAD
=======

>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
function getNodeName(markup) {
  const nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}
<<<<<<< HEAD

=======
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
<<<<<<< HEAD
=======


>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
function createNodesFromMarkup(markup, handleScript) {
  let node = dummyNode;
  invariant(!!dummyNode, 'createNodesFromMarkup dummy not initialized');
  const nodeName = getNodeName(markup);
<<<<<<< HEAD

  const wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    let wrapDepth = wrap[0];
=======
  const wrap = nodeName && getMarkupWrap(nodeName);

  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];
    let wrapDepth = wrap[0];

>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  const scripts = node.getElementsByTagName('script');
<<<<<<< HEAD
=======

>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  if (scripts.length) {
    invariant(handleScript, 'createNodesFromMarkup(...): Unexpected <script> element rendered.');
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  const nodes = Array.from(node.childNodes);
<<<<<<< HEAD
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
=======

  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }

>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  return nodes;
}

module.exports = createNodesFromMarkup;