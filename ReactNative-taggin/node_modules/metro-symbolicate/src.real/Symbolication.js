/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
<<<<<<< HEAD
 * @flow
 * @format
 */

'use strict';

const SourceMetadataMapConsumer = require('./SourceMetadataMapConsumer');

const fs = require('fs');
const invariant = require('invariant');
const path = require('path');

import type {MixedSourceMap, HermesFunctionOffsets} from 'metro-source-map';
// flowlint-next-line untyped-type-import:off
import {typeof SourceMapConsumer} from 'source-map';

type SingleMapModuleIds = {
  segmentId: number,
  localId: ?number,
  ...
};

type ContextOptionsInput = {
  +nameSource?: 'function_names' | 'identifier_names',
  +inputLineStart?: number,
  +inputColumnStart?: number,
  +outputLineStart?: number,
  +outputColumnStart?: number,
  ...
};

// TODO (T46584006): Write the real types for these.
// eslint-disable-next-line lint/no-unclear-flowtypes
type SizeAttributionMap = Object;
// eslint-disable-next-line lint/no-unclear-flowtypes
type ChromeTrace = Object;
// eslint-disable-next-line lint/no-unclear-flowtypes
type ChromeTraceEntry = Object;

type HermesMinidumpCrashInfo = {
  +callstack: $ReadOnlyArray<HermesMinidumpStackFrame | NativeCodeStackFrame>,
  ...
};

type HermesMinidumpStackFrame = $ReadOnly<{|
  ByteCodeOffset: number,
  FunctionID: number,
  CJSModuleOffset: number,
  SourceURL: string,
  StackFrameRegOffs: string,
  SourceLocation?: string,
|}>;

type NativeCodeStackFrame = $ReadOnly<{|
  NativeCode: true,
  StackFrameRegOffs: string,
|}>;

type SymbolicatedStackTrace = $ReadOnlyArray<
  SymbolicatedStackFrame | NativeCodeStackFrame,
>;

type SymbolicatedStackFrame = $ReadOnly<{|
  line: ?number,
  column: ?number,
  source: ?string,
  functionName: ?string,
  name: ?string,
|}>;

const UNKNOWN_MODULE_IDS: SingleMapModuleIds = {
  segmentId: 0,
  localId: undefined,
};

class SymbolicationContext<ModuleIdsT> {
  +options: {
    +nameSource: 'function_names' | 'identifier_names',
    +inputLineStart: number,
    +inputColumnStart: number,
    +outputLineStart: number,
    +outputColumnStart: number,
    ...
  };

  constructor(options: ContextOptionsInput) {
=======
 *
 * @format
 */
"use strict";

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(
          target,
          key,
          Object.getOwnPropertyDescriptor(source, key)
        );
      });
    }
  }
  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

const SourceMetadataMapConsumer = require("./SourceMetadataMapConsumer");

const fs = require("fs");

const invariant = require("invariant");

const nullthrows = require("nullthrows");

const path = require("path");

const UNKNOWN_MODULE_IDS = {
  segmentId: 0,
  localId: undefined
};

class SymbolicationContext {
  constructor(options) {
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    this.options = {
      inputLineStart: 1,
      inputColumnStart: 0,
      outputLineStart: 1,
      outputColumnStart: 0,
<<<<<<< HEAD
      nameSource: 'function_names',
    };
    if (options) {
      for (const option of [
        'inputLineStart',
        'inputColumnStart',
        'outputLineStart',
        'outputColumnStart',
=======
      nameSource: "function_names"
    };

    if (options) {
      for (const option of [
        "inputLineStart",
        "inputColumnStart",
        "outputLineStart",
        "outputColumnStart"
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
      ]) {
        if (options[option] != null) {
          this.options[option] = options[option];
        }
      }
<<<<<<< HEAD
=======

>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
      if (options.nameSource != null) {
        this.options.nameSource = options.nameSource;
      }
    }
<<<<<<< HEAD
  }

  // parse stack trace with String.replace
=======
  } // parse stack trace with String.replace
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  // replace the matched part of stack trace to symbolicated result
  // sample stack trace:
  //  IOS: foo@4:18131, Android: bar:4:18063
  // sample stack trace with module id:
  //  IOS: foo@123.js:4:18131, Android: bar:123.js:4:18063
  // sample stack trace without function name:
  //  123.js:4:18131
  // sample result:
  //  IOS: foo.js:57:foo, Android: bar.js:75:bar
<<<<<<< HEAD
  symbolicate(stackTrace: string): string {
    return stackTrace.replace(
      /(?:([^@: \n(]+)(@|:))?(?:(?:([^@: \n(]+):)?(\d+):(\d+)|\[native code\])/g,
      (match, func, delimiter, fileName, line, column) => {
        if (delimiter === ':' && func && !fileName) {
          fileName = func;
          func = null;
        }
        const original = this.getOriginalPositionFor(
          line,
          column,
          this.parseFileName(fileName || ''),
        );
        return (
          (original.source ?? 'null') +
          ':' +
          (original.line ?? 'null') +
          ':' +
          (original.name ?? 'null')
        );
      },
    );
  }

  // Taking in a map like
=======

  symbolicate(stackTrace) {
    return stackTrace.replace(
      /(?:([^@: \n(]+)(@|:))?(?:(?:([^@: \n(]+):)?(\d+):(\d+)|\[native code\])/g,
      (match, func, delimiter, fileName, line, column) => {
        var _original$source, _original$line, _original$name;

        if (delimiter === ":" && func && !fileName) {
          fileName = func;
          func = null;
        }

        const original = this.getOriginalPositionFor(
          line,
          column,
          this.parseFileName(fileName || "")
        );
        return (
          ((_original$source = original.source) !== null &&
          _original$source !== void 0
            ? _original$source
            : "null") +
          ":" +
          ((_original$line = original.line) !== null &&
          _original$line !== void 0
            ? _original$line
            : "null") +
          ":" +
          ((_original$name = original.name) !== null &&
          _original$name !== void 0
            ? _original$name
            : "null")
        );
      }
    );
  } // Taking in a map like
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  // trampoline offset (optional js function name)
  // JS_0158_xxxxxxxxxxxxxxxxxxxxxx fe 91081
  // JS_0159_xxxxxxxxxxxxxxxxxxxxxx Ft 68651
  // JS_0160_xxxxxxxxxxxxxxxxxxxxxx value 50700
  // JS_0161_xxxxxxxxxxxxxxxxxxxxxx setGapAtCursor 0
  // JS_0162_xxxxxxxxxxxxxxxxxxxxxx (unknown) 50818
  // JS_0163_xxxxxxxxxxxxxxxxxxxxxx value 108267

<<<<<<< HEAD
  symbolicateProfilerMap(mapFile: string): string {
    return fs
      .readFileSync(mapFile, 'utf8')
      .split('\n')
      .slice(0, -1)
      .map(line => {
        const line_list = line.split(' ');
=======
  symbolicateProfilerMap(mapFile) {
    return fs
      .readFileSync(mapFile, "utf8")
      .split("\n")
      .slice(0, -1)
      .map(line => {
        const line_list = line.split(" ");
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
        const trampoline = line_list[0];
        const js_name = line_list[1];
        const offset = parseInt(line_list[2], 10);

        if (!offset) {
<<<<<<< HEAD
          return trampoline + ' ' + trampoline;
=======
          return trampoline + " " + trampoline;
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
        }

        const original = this.getOriginalPositionFor(
          this.options.inputLineStart,
<<<<<<< HEAD
          offset,
        );

        return (
          trampoline +
          ' ' +
          (original.name || js_name) +
          '::' +
          [original.source, original.line, original.column].join(':')
        );
      })
      .join('\n');
  }

  symbolicateAttribution(obj: SizeAttributionMap): SizeAttributionMap {
    const loc = obj.location;
    const line = loc.line != null ? loc.line : this.options.inputLineStart;
    let column = loc.column != null ? loc.column : loc.virtualOffset;
    const file = loc.filename ? this.parseFileName(loc.filename) : null;
    let original = this.getOriginalPositionFor(line, column, file);

    const isBytecodeRange =
      loc.bytecodeSize != null &&
      loc.virtualOffset != null &&
      !loc.column != null;

    // Functions compiled from Metro-bundled modules will often have a little bit
=======
          offset
        );
        return (
          trampoline +
          " " +
          (original.name || js_name) +
          "::" +
          [original.source, original.line, original.column].join(":")
        );
      })
      .join("\n");
  }

  symbolicateAttribution(obj) {
    const loc = obj.location;
    const line = loc.line != null ? loc.line : this.options.inputLineStart;
    let column = Number(loc.column != null ? loc.column : loc.virtualOffset);
    const file = loc.filename ? this.parseFileName(loc.filename) : null;
    let original = this.getOriginalPositionFor(line, column, file);
    const isBytecodeRange =
      loc.bytecodeSize != null &&
      loc.virtualOffset != null &&
      loc.column == null;
    const virtualOffset = Number(loc.virtualOffset);
    const bytecodeSize = Number(loc.bytecodeSize); // Functions compiled from Metro-bundled modules will often have a little bit
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    // of unmapped wrapper code right at the beginning - which is where we query.
    // Let's attribute them to where the inner module code originates instead.
    // This loop is O(n*log(n)) in the size of the function, but we will generally
    // either:
    // 1. Find a non-null mapping within one or two iterations; or
    // 2. Reach the end of the function without encountering mappings - this might
    //    happen for function bodies that never throw (generally very short).
<<<<<<< HEAD
    while (
      isBytecodeRange &&
      original.source == null &&
      ++column < loc.virtualOffset + loc.bytecodeSize
=======

    while (
      isBytecodeRange &&
      original.source == null &&
      ++column < virtualOffset + bytecodeSize
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    ) {
      original = this.getOriginalPositionFor(line, column, file);
    }

    obj.location = {
      file: original.source,
      line: original.line,
<<<<<<< HEAD
      column: original.column,
    };
  }

  // Symbolicate chrome trace "stackFrames" section.
  // Each frame in it has three fields: name, funcVirtAddr(optional), offset(optional).
  // funcVirtAddr and offset are only available if trace is generated from
  // hbc bundle without debug info.
  symbolicateChromeTrace(
    traceFile: string,
    {
      stdout,
      stderr,
    }: {
      stdout: stream$Writable,
      stderr: stream$Writable,
      ...
    },
  ): void {
    const contentJson: ChromeTrace = JSON.parse(
      fs.readFileSync(traceFile, 'utf8'),
    );
    if (contentJson.stackFrames == null) {
      throw new Error('Unable to locate `stackFrames` section in trace.');
    }
    stdout.write(
      'Processing ' + Object.keys(contentJson.stackFrames).length + ' frames\n',
    );
    Object.values(contentJson.stackFrames).forEach(
      (entry: ChromeTraceEntry) => {
        let line;
        let column;

        // Function entrypoint line/column; used for symbolicating function name
        // with legacy source maps (or when --no-function-names is set).
        let funcLine;
        let funcColumn;

        if (entry.funcVirtAddr != null && entry.offset != null) {
          // Without debug information.
          const funcVirtAddr = parseInt(entry.funcVirtAddr, 10);
          const offsetInFunction = parseInt(entry.offset, 10);
          // Main bundle always use hard-coded line value 1.
          // TODO: support multiple bundle/module.
          line = this.options.inputLineStart;
          column = funcVirtAddr + offsetInFunction;
          funcLine = this.options.inputLineStart;
          funcColumn = funcVirtAddr;
        } else if (entry.line != null && entry.column != null) {
          // For hbc bundle with debug info, name field may already have source
          // information for the bundle; we still can use the Metro
          // source map to symbolicate the bundle frame addresses further to its
          // original source code.
          line = entry.line;
          column = entry.column;

          funcLine = entry.funcLine;
          funcColumn = entry.funcColumn;
        } else {
          // Native frames.
          return;
        }

        // Symbolicate original file/line/column.
        const addressOriginal = this.getOriginalPositionDetailsFor(
          line,
          column,
        );

        let frameName;
        if (addressOriginal.functionName) {
          frameName = addressOriginal.functionName;
        } else {
          frameName = entry.name;
          // Symbolicate function name.
          if (funcLine != null && funcColumn != null) {
            const funcOriginal = this.getOriginalPositionFor(
              funcLine,
              funcColumn,
            );
            if (funcOriginal.name != null) {
              frameName = funcOriginal.name;
            }
          } else {
            // No function line/column info.
            (stderr || stdout).write(
              'Warning: no function prolog line/column info; name may be wrong\n',
            );
          }
        }

        // Output format is: funcName(file:line:column)
        entry.name = [
          frameName,
          '(',
          [
            addressOriginal.source ?? 'null',
            addressOriginal.line ?? 'null',
            addressOriginal.column ?? 'null',
          ].join(':'),
          ')',
        ].join('');
      },
    );
    stdout.write('Writing to ' + traceFile + '\n');
    fs.writeFileSync(traceFile, JSON.stringify(contentJson));
  }

=======
      column: original.column
    };
  } // Symbolicate chrome trace "stackFrames" section.
  // Each frame in it has three fields: name, funcVirtAddr(optional), offset(optional).
  // funcVirtAddr and offset are only available if trace is generated from
  // hbc bundle without debug info.

  symbolicateChromeTrace(traceFile, _ref) {
    let stdout = _ref.stdout,
      stderr = _ref.stderr;
    const content = JSON.parse(fs.readFileSync(traceFile, "utf8"));

    if (content.stackFrames == null) {
      throw new Error("Unable to locate `stackFrames` section in trace.");
    }

    const keys = Object.keys(content.stackFrames);
    stdout.write("Processing " + keys.length + " frames\n");
    keys.forEach(key => {
      var _addressOriginal$sour, _addressOriginal$line, _addressOriginal$colu;

      const entry = content.stackFrames[key];
      let line;
      let column; // Function entrypoint line/column; used for symbolicating function name
      // with legacy source maps (or when --no-function-names is set).

      let funcLine;
      let funcColumn;

      if (entry.funcVirtAddr != null && entry.offset != null) {
        // Without debug information.
        const funcVirtAddr = parseInt(entry.funcVirtAddr, 10);
        const offsetInFunction = parseInt(entry.offset, 10); // Main bundle always use hard-coded line value 1.
        // TODO: support multiple bundle/module.

        line = this.options.inputLineStart;
        column = funcVirtAddr + offsetInFunction;
        funcLine = this.options.inputLineStart;
        funcColumn = funcVirtAddr;
      } else if (entry.line != null && entry.column != null) {
        // For hbc bundle with debug info, name field may already have source
        // information for the bundle; we still can use the Metro
        // source map to symbolicate the bundle frame addresses further to its
        // original source code.
        line = entry.line;
        column = entry.column;
        funcLine = entry.funcLine;
        funcColumn = entry.funcColumn;
      } else {
        // Native frames.
        return;
      } // Symbolicate original file/line/column.

      const addressOriginal = this.getOriginalPositionDetailsFor(line, column);
      let frameName;

      if (addressOriginal.functionName) {
        frameName = addressOriginal.functionName;
      } else {
        frameName = entry.name; // Symbolicate function name.

        if (funcLine != null && funcColumn != null) {
          const funcOriginal = this.getOriginalPositionFor(
            funcLine,
            funcColumn
          );

          if (funcOriginal.name != null) {
            frameName = funcOriginal.name;
          }
        } else {
          // No function line/column info.
          (stderr || stdout).write(
            "Warning: no function prolog line/column info; name may be wrong\n"
          );
        }
      } // Output format is: funcName(file:line:column)

      entry.name = [
        frameName,
        "(",
        [
          (_addressOriginal$sour = addressOriginal.source) !== null &&
          _addressOriginal$sour !== void 0
            ? _addressOriginal$sour
            : "null",
          (_addressOriginal$line = addressOriginal.line) !== null &&
          _addressOriginal$line !== void 0
            ? _addressOriginal$line
            : "null",
          (_addressOriginal$colu = addressOriginal.column) !== null &&
          _addressOriginal$colu !== void 0
            ? _addressOriginal$colu
            : "null"
        ].join(":"),
        ")"
      ].join("");
    });
    stdout.write("Writing to " + traceFile + "\n");
    fs.writeFileSync(traceFile, JSON.stringify(content));
  }
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  /*
   * A helper function to return a mapping {line, column} object for a given input
   * line and column, and optionally a module ID.
   */
<<<<<<< HEAD
  getOriginalPositionFor(
    lineNumber: ?number,
    columnNumber: ?number,
    moduleIds: ?ModuleIdsT,
  ): {|
    line: ?number,
    column: ?number,
    source: ?string,
    name: ?string,
  |} {
    const position = this.getOriginalPositionDetailsFor(
      lineNumber,
      columnNumber,
      moduleIds,
=======

  getOriginalPositionFor(lineNumber, columnNumber, moduleIds) {
    const position = this.getOriginalPositionDetailsFor(
      lineNumber,
      columnNumber,
      moduleIds
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    );
    return {
      line: position.line,
      column: position.column,
      source: position.source,
<<<<<<< HEAD
      name: position.functionName ? position.functionName : position.name,
    };
  }

=======
      name: position.functionName ? position.functionName : position.name
    };
  }
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  /*
   * Symbolicates the JavaScript stack trace extracted from the minidump
   * produced by hermes
   */
<<<<<<< HEAD
  symbolicateHermesMinidumpTrace(
    crashInfo: HermesMinidumpCrashInfo,
  ): SymbolicatedStackTrace {
    throw new Error('Not implemented');
  }

=======

  symbolicateHermesMinidumpTrace(crashInfo) {
    throw new Error("Not implemented");
  }
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  /*
   * An internal helper function similar to getOriginalPositionFor. This one
   * returns both `name` and `functionName` fields so callers can distinguish the
   * source of the name.
   */
<<<<<<< HEAD
  getOriginalPositionDetailsFor(
    lineNumber: ?number,
    columnNumber: ?number,
    moduleIds: ?ModuleIdsT,
  ): SymbolicatedStackFrame {
    throw new Error('Not implemented');
  }

  parseFileName(str: string): ModuleIdsT {
    throw new Error('Not implemented');
  }
}

class SingleMapSymbolicationContext extends SymbolicationContext<SingleMapModuleIds> {
  +_segments: {
    +[id: string]: {|
      +consumer: SourceMapConsumer,
      +moduleOffsets: $ReadOnlyArray<number>,
      +sourceFunctionsConsumer: ?SourceMetadataMapConsumer,
      +hermesOffsets: ?HermesFunctionOffsets,
    |},
    ...,
  };
  +_hasLegacySegments: boolean;

  constructor(
    SourceMapConsumer: SourceMapConsumer,
    sourceMapContent: string | MixedSourceMap,
    options: ContextOptionsInput = {},
  ) {
    super(options);
    const useFunctionNames = this.options.nameSource === 'function_names';
    const sourceMapJson: MixedSourceMap =
      typeof sourceMapContent === 'string'
        ? JSON.parse(sourceMapContent.replace(/^\)\]\}'/, ''))
        : sourceMapContent;
    const {x_hermes_function_offsets} = sourceMapJson;
    const segments = {
      '0': {
        consumer: new SourceMapConsumer(sourceMapJson),
        moduleOffsets: sourceMapJson.x_facebook_offsets || [],
        sourceFunctionsConsumer: useFunctionNames
          ? new SourceMetadataMapConsumer(sourceMapJson)
          : null,
        hermesOffsets: x_hermes_function_offsets,
      },
    };
    if (sourceMapJson.x_facebook_segments) {
      for (const key of Object.keys(sourceMapJson.x_facebook_segments)) {
        const map = sourceMapJson.x_facebook_segments[key];
        segments[key] = {
          consumer: new SourceMapConsumer(map),
          moduleOffsets: map.x_facebook_offsets || [],
          sourceFunctionsConsumer: useFunctionNames
            ? new SourceMetadataMapConsumer(map)
            : null,
          hermesOffsets: map.x_hermes_function_offsets,
        };
      }
    }
=======

  getOriginalPositionDetailsFor(lineNumber, columnNumber, moduleIds) {
    throw new Error("Not implemented");
  }

  parseFileName(str) {
    throw new Error("Not implemented");
  }
}

class SingleMapSymbolicationContext extends SymbolicationContext {
  // $FlowFixMe[value-as-type]
  constructor(SourceMapConsumer, sourceMapContent) { // $FlowFixMe[value-as-type]
    let options =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    super(options);
    this._SourceMapConsumer = SourceMapConsumer;
    const sourceMapJson =
      typeof sourceMapContent === "string"
        ? JSON.parse(sourceMapContent.replace(/^\)\]\}'/, ""))
        : sourceMapContent;
    const segments = {
      "0": this._initSegment(sourceMapJson)
    };

    if (sourceMapJson.x_facebook_segments) {
      for (const key of Object.keys(sourceMapJson.x_facebook_segments)) {
        const map = sourceMapJson.x_facebook_segments[key];
        segments[key] = this._initSegment(map);
      }
    }

>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    this._hasLegacySegments = sourceMapJson.x_facebook_segments != null;
    this._segments = segments;
  }

<<<<<<< HEAD
  symbolicateHermesMinidumpTrace(
    crashInfo: HermesMinidumpCrashInfo,
  ): SymbolicatedStackTrace {
    const symbolicatedTrace = [];
    const {callstack} = crashInfo;
=======
  _initSegment(map) {
    const useFunctionNames = this.options.nameSource === "function_names";
    const SourceMapConsumer = this._SourceMapConsumer;
    return {
      get consumer() {
        Object.defineProperty(this, "consumer", {
          value: new SourceMapConsumer(map)
        });
        return this.consumer;
      },

      moduleOffsets: map.x_facebook_offsets || [],

      get sourceFunctionsConsumer() {
        Object.defineProperty(this, "sourceFunctionsConsumer", {
          value: useFunctionNames ? new SourceMetadataMapConsumer(map) : null
        });
        return this.sourceFunctionsConsumer;
      },

      hermesOffsets: map.x_hermes_function_offsets
    };
  }

  symbolicateHermesMinidumpTrace(crashInfo) {
    const symbolicatedTrace = [];
    const callstack = crashInfo.callstack;

>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    if (callstack != null) {
      for (const stackItem of callstack) {
        if (stackItem.NativeCode) {
          symbolicatedTrace.push(stackItem);
        } else {
<<<<<<< HEAD
          const {
            CJSModuleOffset,
            SourceURL,
            FunctionID,
            ByteCodeOffset: localOffset,
          } = stackItem;
          const moduleInformation = this._hasLegacySegments
            ? this.parseFileName(SourceURL)
            : UNKNOWN_MODULE_IDS;
          const generatedLine = CJSModuleOffset + this.options.inputLineStart;
          const segment = this._segments[
            moduleInformation.segmentId.toString()
          ];
          const hermesOffsets = segment?.hermesOffsets;
=======
          const CJSModuleOffset = stackItem.CJSModuleOffset,
            SegmentID = stackItem.SegmentID,
            SourceURL = stackItem.SourceURL,
            FunctionID = stackItem.FunctionID,
            localOffset = stackItem.ByteCodeOffset;
          const cjsModuleOffsetOrSegmentID = nullthrows(
            CJSModuleOffset !== null && CJSModuleOffset !== void 0
              ? CJSModuleOffset
              : SegmentID,
            "Either CJSModuleOffset or SegmentID must be specified in the Hermes stack frame"
          );
          const moduleInformation = this._hasLegacySegments
            ? this.parseFileName(SourceURL)
            : UNKNOWN_MODULE_IDS;
          const generatedLine =
            cjsModuleOffsetOrSegmentID + this.options.inputLineStart;

          const segment = this._segments[
            moduleInformation.segmentId.toString()
          ];

          const hermesOffsets =
            segment === null || segment === void 0
              ? void 0
              : segment.hermesOffsets;

>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
          if (!hermesOffsets) {
            symbolicatedTrace.push({
              line: null,
              column: null,
              source: null,
              functionName: null,
<<<<<<< HEAD
              name: null,
            });
          } else {
            const segmentOffsets = hermesOffsets[Number(CJSModuleOffset)];
=======
              name: null
            });
          } else {
            const segmentOffsets =
              hermesOffsets[Number(cjsModuleOffsetOrSegmentID)];
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
            const generatedColumn =
              segmentOffsets[FunctionID] +
              localOffset +
              this.options.inputColumnStart;
            const originalPosition = this.getOriginalPositionDetailsFor(
              generatedLine,
              generatedColumn,
<<<<<<< HEAD
              moduleInformation,
=======
              moduleInformation
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
            );
            symbolicatedTrace.push(originalPosition);
          }
        }
      }
    }
<<<<<<< HEAD
    return symbolicatedTrace;
  }

=======

    return symbolicatedTrace;
  }
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  /*
   * An internal helper function similar to getOriginalPositionFor. This one
   * returns both `name` and `functionName` fields so callers can distinguish the
   * source of the name.
   */
<<<<<<< HEAD
  getOriginalPositionDetailsFor(
    lineNumber: ?number,
    columnNumber: ?number,
    moduleIds: ?SingleMapModuleIds,
  ): SymbolicatedStackFrame {
=======

  getOriginalPositionDetailsFor(lineNumber, columnNumber, moduleIds) {
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    // Adjust arguments to source-map's input coordinates
    lineNumber =
      lineNumber != null
        ? lineNumber - this.options.inputLineStart + 1
        : lineNumber;
    columnNumber =
      columnNumber != null
        ? columnNumber - this.options.inputColumnStart + 0
        : columnNumber;

    if (!moduleIds) {
      moduleIds = UNKNOWN_MODULE_IDS;
    }

    let moduleLineOffset = 0;
<<<<<<< HEAD
    const metadata = this._segments[moduleIds.segmentId + ''];
    const {localId} = moduleIds;
    if (localId != null) {
      const {moduleOffsets} = metadata;
      if (!moduleOffsets) {
        throw new Error(
          'Module ID given for a source map that does not have ' +
            'an x_facebook_offsets field',
        );
      }
      if (moduleOffsets[localId] == null) {
        throw new Error('Unknown module ID: ' + localId);
      }
      moduleLineOffset = moduleOffsets[localId];
    }
    const original = metadata.consumer.originalPositionFor({
      line: Number(lineNumber) + moduleLineOffset,
      column: Number(columnNumber),
    });
=======
    const metadata = this._segments[moduleIds.segmentId + ""];
    const _moduleIds = moduleIds,
      localId = _moduleIds.localId;

    if (localId != null) {
      const moduleOffsets = metadata.moduleOffsets;

      if (!moduleOffsets) {
        throw new Error(
          "Module ID given for a source map that does not have " +
            "an x_facebook_offsets field"
        );
      }

      if (moduleOffsets[localId] == null) {
        throw new Error("Unknown module ID: " + localId);
      }

      moduleLineOffset = moduleOffsets[localId];
    }

    const original = metadata.consumer.originalPositionFor({
      line: Number(lineNumber) + moduleLineOffset,
      column: Number(columnNumber)
    });

>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    if (metadata.sourceFunctionsConsumer) {
      original.functionName =
        metadata.sourceFunctionsConsumer.functionNameFor(original) || null;
    } else {
      original.functionName = null;
    }
<<<<<<< HEAD
    return {
      ...original,
      line:
        original.line != null
          ? original.line - 1 + this.options.outputLineStart
          : original.line,
      column:
        original.column != null
          ? original.column - 0 + this.options.outputColumnStart
          : original.column,
    };
  }

  parseFileName(str: string): SingleMapModuleIds {
=======

    return _objectSpread(
      _objectSpread({}, original),
      {},
      {
        line:
          original.line != null
            ? original.line - 1 + this.options.outputLineStart
            : original.line,
        column:
          original.column != null
            ? original.column - 0 + this.options.outputColumnStart
            : original.column
      }
    );
  }

  parseFileName(str) {
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    return parseSingleMapFileName(str);
  }
}

<<<<<<< HEAD
class DirectorySymbolicationContext extends SymbolicationContext<string> {
  +_fileMaps: Map<string, SingleMapSymbolicationContext>;
  +_rootDir: string;
  +_SourceMapConsumer: SourceMapConsumer;

  constructor(
    SourceMapConsumer: SourceMapConsumer,
    rootDir: string,
    options: ContextOptionsInput = {},
  ) {
=======
class DirectorySymbolicationContext extends SymbolicationContext {
  // $FlowFixMe[value-as-type]
  constructor(SourceMapConsumer, rootDir) { // $FlowFixMe[value-as-type]
    let options =
      arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
    super(options);
    this._fileMaps = new Map();
    this._rootDir = rootDir;
    this._SourceMapConsumer = SourceMapConsumer;
  }

<<<<<<< HEAD
  _loadMap(mapFilename: string): SingleMapSymbolicationContext {
    invariant(
      fs.existsSync(mapFilename),
      `Could not read source map from '${mapFilename}'`,
    );
    let fileMap = this._fileMaps.get(mapFilename);
    if (fileMap == null) {
      fileMap = new SingleMapSymbolicationContext(
        this._SourceMapConsumer,
        fs.readFileSync(mapFilename, 'utf8'),
        this.options,
      );
      this._fileMaps.set(mapFilename, fileMap);
    }
    return fileMap;
  }

=======
  _loadMap(mapFilename) {
    invariant(
      fs.existsSync(mapFilename),
      `Could not read source map from '${mapFilename}'`
    );

    let fileMap = this._fileMaps.get(mapFilename);

    if (fileMap == null) {
      fileMap = new SingleMapSymbolicationContext(
        this._SourceMapConsumer,
        fs.readFileSync(mapFilename, "utf8"),
        this.options
      );

      this._fileMaps.set(mapFilename, fileMap);
    }

    return fileMap;
  }
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
  /*
   * An internal helper function similar to getOriginalPositionFor. This one
   * returns both `name` and `functionName` fields so callers can distinguish the
   * source of the name.
   */
<<<<<<< HEAD
  getOriginalPositionDetailsFor(
    lineNumber: ?number,
    columnNumber: ?number,
    filename: ?string,
  ): SymbolicatedStackFrame {
    invariant(
      filename != null,
      'filename is required for DirectorySymbolicationContext',
    );
    const mapFilename = path.join(this._rootDir, filename + '.map');
    if (!fs.existsSync(mapFilename)) {
=======

  getOriginalPositionDetailsFor(lineNumber, columnNumber, filename) {
    invariant(
      filename != null,
      "filename is required for DirectorySymbolicationContext"
    );
    let mapFilename;
    const relativeFilename = path.relative(
      this._rootDir,
      path.resolve(this._rootDir, filename)
    ); // Lock down access to files outside the root dir.

    if (!relativeFilename.startsWith("..")) {
      mapFilename = path.join(this._rootDir, relativeFilename + ".map");
    }

    if (mapFilename == null || !fs.existsSync(mapFilename)) {
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
      // Adjust arguments to the output coordinates
      lineNumber =
        lineNumber != null
          ? lineNumber -
            this.options.inputLineStart +
            this.options.outputLineStart
          : lineNumber;
      columnNumber =
        columnNumber != null
          ? columnNumber -
            this.options.inputColumnStart +
            this.options.outputColumnStart
          : columnNumber;
<<<<<<< HEAD

=======
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
      return {
        line: lineNumber,
        column: columnNumber,
        source: filename,
        name: null,
<<<<<<< HEAD
        functionName: null,
      };
    }
    return this._loadMap(mapFilename).getOriginalPositionDetailsFor(
      lineNumber,
      columnNumber,
    );
  }

  parseFileName(str: string): string {
    return str;
  }
}

=======
        functionName: null
      };
    }

    return this._loadMap(mapFilename).getOriginalPositionDetailsFor(
      lineNumber,
      columnNumber
    );
  }

  parseFileName(str) {
    return str;
  }
}
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
/*
 * If the file name of a stack frame is numeric (+ ".js"), we assume it's a
 * lazily injected module coming from a "random access bundle". We are using
 * special source maps for these bundles, so that we can symbolicate stack
 * traces for multiple injected files with a single source map.
 *
 * There is also a convention for callsites that are in split segments of a
 * bundle, named either `seg-3.js` for segment #3 for example, or `seg-3_5.js`
 * for module #5 of segment #3 of a segmented RAM bundle.
 */
<<<<<<< HEAD
function parseSingleMapFileName(str: string): SingleMapModuleIds {
  const modMatch = str.match(/^(\d+).js$/);
  if (modMatch != null) {
    return {segmentId: 0, localId: Number(modMatch[1])};
  }
  const segMatch = str.match(/^seg-(\d+)(?:_(\d+))?.js$/);
  if (segMatch != null) {
    return {
      segmentId: Number(segMatch[1]),
      localId: segMatch[2] ? Number(segMatch[2]) : null,
    };
  }
  return UNKNOWN_MODULE_IDS;
}

function createContext(
  SourceMapConsumer: SourceMapConsumer,
  sourceMapContent: string | MixedSourceMap,
  options: ContextOptionsInput = {},
): SingleMapSymbolicationContext {
  return new SingleMapSymbolicationContext(
    SourceMapConsumer,
    sourceMapContent,
    options,
  );
}

function unstable_createDirectoryContext(
  SourceMapConsumer: SourceMapConsumer,
  rootDir: string,
  options: ContextOptionsInput = {},
): DirectorySymbolicationContext {
  return new DirectorySymbolicationContext(SourceMapConsumer, rootDir, options);
}

function getOriginalPositionFor<ModuleIdsT>(
  lineNumber: ?number,
  columnNumber: ?number,
  moduleIds: ?ModuleIdsT,
  context: SymbolicationContext<ModuleIdsT>,
): {|
  line: ?number,
  column: ?number,
  source: ?string,
  name: ?string,
|} {
  return context.getOriginalPositionFor(lineNumber, columnNumber, moduleIds);
}

function symbolicate<ModuleIdsT>(
  stackTrace: string,
  context: SymbolicationContext<ModuleIdsT>,
): string {
  return context.symbolicate(stackTrace);
}

function symbolicateProfilerMap<ModuleIdsT>(
  mapFile: string,
  context: SymbolicationContext<ModuleIdsT>,
): string {
  return context.symbolicateProfilerMap(mapFile);
}

function symbolicateAttribution<ModuleIdsT>(
  obj: SizeAttributionMap,
  context: SymbolicationContext<ModuleIdsT>,
): SizeAttributionMap {
  return context.symbolicateAttribution(obj);
}

function symbolicateChromeTrace<ModuleIdsT>(
  traceFile: string,
  {
    stdout,
    stderr,
  }: {
    stdout: stream$Writable,
    stderr: stream$Writable,
    ...
  },
  context: SymbolicationContext<ModuleIdsT>,
): void {
  return context.symbolicateChromeTrace(traceFile, {stdout, stderr});
=======

function parseSingleMapFileName(str) {
  const modMatch = str.match(/^(\d+).js$/);

  if (modMatch != null) {
    return {
      segmentId: 0,
      localId: Number(modMatch[1])
    };
  }

  const segMatch = str.match(/^seg-(\d+)(?:_(\d+))?.js$/);

  if (segMatch != null) {
    return {
      segmentId: Number(segMatch[1]),
      localId: segMatch[2] ? Number(segMatch[2]) : null
    };
  }

  return UNKNOWN_MODULE_IDS;
}

function createContext(SourceMapConsumer, sourceMapContent) { // $FlowFixMe[value-as-type]
  let options =
    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return new SingleMapSymbolicationContext(
    SourceMapConsumer,
    sourceMapContent,
    options
  );
}

function unstable_createDirectoryContext(SourceMapConsumer, rootDir) { // $FlowFixMe[value-as-type]
  let options =
    arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return new DirectorySymbolicationContext(SourceMapConsumer, rootDir, options);
}

function getOriginalPositionFor(lineNumber, columnNumber, moduleIds, context) {
  return context.getOriginalPositionFor(lineNumber, columnNumber, moduleIds);
}

function symbolicate(stackTrace, context) {
  return context.symbolicate(stackTrace);
}

function symbolicateProfilerMap(mapFile, context) {
  return context.symbolicateProfilerMap(mapFile);
}

function symbolicateAttribution(obj, context) {
  context.symbolicateAttribution(obj);
}

function symbolicateChromeTrace(traceFile, _ref2, context) {
  let stdout = _ref2.stdout,
    stderr = _ref2.stderr;
  return context.symbolicateChromeTrace(traceFile, {
    stdout,
    stderr
  });
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
}

module.exports = {
  createContext,
  unstable_createDirectoryContext,
  getOriginalPositionFor,
  parseFileName: parseSingleMapFileName,
  symbolicate,
  symbolicateProfilerMap,
  symbolicateAttribution,
  symbolicateChromeTrace,
<<<<<<< HEAD
  SourceMetadataMapConsumer,
=======
  SourceMetadataMapConsumer
>>>>>>> e75a71e2c6ac3e5d484a463ebda2ebf8c6ccb707
};
